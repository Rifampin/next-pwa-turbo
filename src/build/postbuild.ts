/**
 * Postbuild script for next-pwa-turbo
 *
 * This module runs after Next.js build completes to:
 * 1. Read the generated PWA manifest from .next/pwa-manifest.json
 * 2. Load PWA configuration from next.config or .pwarc.json
 * 3. Compile the service worker with esbuild
 *
 * Security principles:
 * - No eval() or new Function()
 * - All paths validated for traversal
 * - Graceful handling of missing files
 */

import * as fs from 'node:fs/promises';
import * as path from 'node:path';
import { fileURLToPath } from 'node:url';
import {
  compileServiceWorker,
  resolveSwSrc,
  resolveSwDest,
  type PrecacheEntry,
} from './compile-sw.js';
import { validateConfig, getDefaultConfig, type PWAConfig } from '../config/schema.js';
import { hasPathTraversal } from '../utils/security.js';

// =============================================================================
// Types
// =============================================================================

/**
 * Configuration source type
 */
type ConfigSource = 'next.config' | '.pwarc.json' | 'default';

/**
 * Result of loading configuration
 */
interface ConfigLoadResult {
  config: PWAConfig;
  source: ConfigSource;
}

/**
 * Result of the postbuild process
 */
export interface PostbuildResult {
  success: boolean;
  swPath: string | null;
  manifestEntries: number;
  warnings: string[];
  errors: string[];
}

// =============================================================================
// Logger
// =============================================================================

const logger = {
  info: (msg: string) => console.log(`[next-pwa-turbo] ${msg}`),
  warn: (msg: string) => console.warn(`[next-pwa-turbo] WARNING: ${msg}`),
  error: (msg: string) => console.error(`[next-pwa-turbo] ERROR: ${msg}`),
};

// =============================================================================
// Configuration Loading
// =============================================================================

/**
 * Attempts to load PWA config from .pwarc.json
 */
async function loadPwarcConfig(projectDir: string): Promise<PWAConfig | null> {
  const pwarcPath = path.join(projectDir, '.pwarc.json');

  try {
    const content = await fs.readFile(pwarcPath, 'utf-8');
    const rawConfig = JSON.parse(content);
    return validateConfig(rawConfig);
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
      // File doesn't exist, that's okay
      return null;
    }

    // JSON parse error or validation error
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.warn(`Failed to load .pwarc.json: ${errorMessage}`);
    return null;
  }
}

/**
 * Attempts to load PWA config from next.config.ts/js
 * Note: In a real implementation, this would need to parse the Next.js config
 * For now, we return null and rely on .pwarc.json or defaults
 */
async function loadNextConfig(projectDir: string): Promise<PWAConfig | null> {
  // Try to find next.config.ts or next.config.js
  const configPaths = [
    path.join(projectDir, 'next.config.ts'),
    path.join(projectDir, 'next.config.mts'),
    path.join(projectDir, 'next.config.js'),
    path.join(projectDir, 'next.config.mjs'),
  ];

  for (const configPath of configPaths) {
    try {
      await fs.access(configPath);
      // Found a next.config file
      // For now, we cannot dynamically import TS files
      // Users should use .pwarc.json for configuration
      logger.info(`Found ${path.basename(configPath)}, but reading PWA config from it is not yet supported`);
      logger.info(`Please use .pwarc.json for PWA configuration`);
      return null;
    } catch {
      // File doesn't exist, continue
    }
  }

  return null;
}

/**
 * Loads PWA configuration from available sources
 */
async function loadConfig(projectDir: string): Promise<ConfigLoadResult> {
  // Try .pwarc.json first (recommended)
  const pwarcConfig = await loadPwarcConfig(projectDir);
  if (pwarcConfig) {
    logger.info('Loaded PWA configuration from .pwarc.json');
    return { config: pwarcConfig, source: '.pwarc.json' };
  }

  // Try next.config
  const nextConfig = await loadNextConfig(projectDir);
  if (nextConfig) {
    logger.info('Loaded PWA configuration from next.config');
    return { config: nextConfig, source: 'next.config' };
  }

  // Fall back to defaults
  logger.info('Using default PWA configuration');
  return { config: getDefaultConfig(), source: 'default' };
}

// =============================================================================
// Manifest Loading
// =============================================================================

/**
 * Loads the precache manifest generated by the Build Adapter
 */
async function loadPrecacheManifest(
  projectDir: string,
  distDir: string = '.next'
): Promise<PrecacheEntry[] | null> {
  const manifestPath = path.join(projectDir, distDir, 'pwa-manifest.json');

  // Validate path doesn't have traversal
  if (hasPathTraversal(manifestPath)) {
    logger.error('Manifest path contains invalid traversal');
    return null;
  }

  try {
    const content = await fs.readFile(manifestPath, 'utf-8');
    const manifest = JSON.parse(content) as PrecacheEntry[];

    // Basic validation
    if (!Array.isArray(manifest)) {
      logger.error('Invalid manifest format: expected array');
      return null;
    }

    return manifest;
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
      logger.error(`Manifest file not found: ${manifestPath}`);
      logger.error('Make sure to run the Next.js build first');
      return null;
    }

    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error(`Failed to load manifest: ${errorMessage}`);
    return null;
  }
}

// =============================================================================
// Package Root Resolution
// =============================================================================

/**
 * Gets the root directory of the next-pwa-turbo package
 * This is needed to locate the default SW templates
 */
function getPackageRoot(): string {
  // In ESM, use import.meta.url to get current file location
  const currentFile = fileURLToPath(import.meta.url);
  // Go up from dist/build/postbuild.js to package root
  return path.resolve(path.dirname(currentFile), '..', '..');
}

// =============================================================================
// Main Postbuild Function
// =============================================================================

/**
 * Runs the postbuild process to compile the service worker.
 *
 * This function:
 * 1. Loads PWA configuration from .pwarc.json, next.config, or defaults
 * 2. Reads the precache manifest from .next/pwa-manifest.json
 * 3. Compiles the service worker using esbuild
 * 4. Writes the output to the configured destination
 *
 * @param projectDir - The root directory of the Next.js project
 * @returns Result of the postbuild process
 *
 * @example
 * ```ts
 * import { runPostbuild } from 'next-pwa-turbo/build';
 *
 * const result = await runPostbuild(process.cwd());
 * if (!result.success) {
 *   console.error('Postbuild failed:', result.errors);
 *   process.exit(1);
 * }
 * ```
 */
export async function runPostbuild(projectDir: string): Promise<PostbuildResult> {
  const warnings: string[] = [];
  const errors: string[] = [];

  logger.info('Starting postbuild process...');
  logger.info(`Project directory: ${projectDir}`);

  // Validate project directory
  const resolvedProjectDir = path.resolve(projectDir);

  try {
    const stat = await fs.stat(resolvedProjectDir);
    if (!stat.isDirectory()) {
      errors.push(`Project path is not a directory: ${resolvedProjectDir}`);
      return { success: false, swPath: null, manifestEntries: 0, warnings, errors };
    }
  } catch (error) {
    errors.push(`Project directory not found: ${resolvedProjectDir}`);
    return { success: false, swPath: null, manifestEntries: 0, warnings, errors };
  }

  // Load configuration
  const { config, source } = await loadConfig(resolvedProjectDir);

  // Check if PWA is disabled
  if (config.disable) {
    logger.info('PWA is disabled in configuration, skipping postbuild');
    return { success: true, swPath: null, manifestEntries: 0, warnings, errors };
  }

  // Check if in development mode and devOptions is not enabled
  const isProduction = process.env['NODE_ENV'] === 'production';
  if (!isProduction && !config.devOptions?.enabled) {
    logger.info('Skipping postbuild in development mode (set devOptions.enabled: true to enable)');
    return { success: true, swPath: null, manifestEntries: 0, warnings, errors };
  }

  // Load precache manifest
  const manifest = await loadPrecacheManifest(resolvedProjectDir);
  if (!manifest) {
    errors.push('Failed to load precache manifest');
    return { success: false, swPath: null, manifestEntries: 0, warnings, errors };
  }

  logger.info(`Loaded ${manifest.length} entries from precache manifest`);

  // Resolve paths
  const packageRoot = getPackageRoot();
  const swSrc = await resolveSwSrc(config, resolvedProjectDir, packageRoot);
  const swDest = resolveSwDest(config, resolvedProjectDir);

  logger.info(`Service worker source: ${swSrc}`);
  logger.info(`Service worker destination: ${swDest}`);

  // Determine build mode
  const mode = process.env['NODE_ENV'] === 'production' ? 'production' : 'development';

  // Compile the service worker
  const result = await compileServiceWorker({
    manifest,
    swSrc,
    swDest,
    mode,
    config,
  });

  // Collect warnings and errors
  warnings.push(...result.warnings);
  errors.push(...result.errors);

  if (result.success) {
    logger.info('Postbuild completed successfully!');
    logger.info(`Service worker written to: ${swDest}`);
    logger.info(`Output size: ${(result.outputSize / 1024).toFixed(2)} KB`);

    return {
      success: true,
      swPath: result.outputPath,
      manifestEntries: manifest.length,
      warnings,
      errors,
    };
  } else {
    logger.error('Postbuild failed');
    return {
      success: false,
      swPath: null,
      manifestEntries: manifest.length,
      warnings,
      errors,
    };
  }
}

/**
 * CLI entry point - runs postbuild with current working directory
 */
export async function runPostbuildCLI(): Promise<void> {
  const projectDir = process.cwd();

  try {
    const result = await runPostbuild(projectDir);

    if (!result.success) {
      // Errors already logged
      process.exit(1);
    }

    // Log any warnings
    for (const warning of result.warnings) {
      logger.warn(warning);
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger.error(`Unexpected error: ${errorMessage}`);
    process.exit(1);
  }
}
